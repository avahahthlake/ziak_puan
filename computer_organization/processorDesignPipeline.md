# Processor design and pipelining üñ•Ô∏è ü™à

## Abstract Register-Transfer-Notation of SRC

The abstract RTN shows behaviour of instructions without focusing on exact hardware (we focus only on conceptual operations)

```format
IR <- Memory[PC]
PC <- PC + 4
Decode IR
Execute instruction
```

| Instruction | Abstract RTN | Concrete RTN |
| --------------- | --------------- | --------------- |
| LOAD | R[Rd]<-Mem[R[Rs]+x] | A<-R[Rs]; C<-A+x; MAR<-C; MDR<-Mem[MAR]; R[Rd]<-MDR|
| STORE | Mem[R[Rs]+x]<-R[Rd] | A<-R[Rs]; C<-A+x; MAR<-C; MDR<-R[Rd]; Mem[MAR]<-MDR|
| ADD | R[Rd]<-R[Rs]+R[Rt] | A<-R[Rs]; B<-R[Rt]; C<-A+B; R[Rd]<-C|
| SHIFT | R[Rd]<-Shift[R[Rs], sh] | A<-R[Rs]; C<-SHIFT[A, sh]; R[Rd]<-C |
|BRANCH|If cond then PC<-PC+offset|A<-cond_eval; If A then PC<-PC + offset|

```idea
R[Rd] <- Mem[R[Rs] + x]

means...

"Take the value from memory address at Rs + offset and put it in Rd"
```

## Synthesis of control signals in the ***Control Unit***

>‚õ©Ô∏è The purpose of these **control signals** is to generate precise sequence of signals needed to manage components like the ALU, register and memory during program execution.

The synthesis of control signals in the *control unit* can happen with two design approaches.

### Hardwired control

* This approach uses fixed logic circuits, combinational and logic circuits to generate control signals directly from the instruction's op-code, status flags, timing signals.
* The sequence of operations is determined by the physical wiring of logic gates, flip-flops, decoders, sequence counter.
* Speed => Hardwired control is faster because signals are directly generated by *dedicated hardware*, without needing to fetch instruction from memory.
* Flexibility => It lacks flexibility though. As it is difficult to manually add new instructions as that would require us to tinker the hardware.
* Typically used in RISC (Reduced Instruction Set Computer)

### Microprogrammed control

Here, in this approach, control signals are generated by a dedicated program called "microprogram". This is stored in a special, fact memory called "control memory". Each machine instruction in the main program, is broken down into a sequence of low level instructions called "microinstructions".
* It is slower than hardwired.
* It is much flexible than hardwired approach.
* It is typically used in CISC(complex instruction set computer)

## Instruction propagation in a pipeline

This is an *assembly-line-technique* where multiple instructions are processed simultaneously across a series of sequential stages.

> Throughput is a fundamental performance metric for a processor that measure the number of tasks completed per unit of time.

Example is . Consider a sequence of 4 independent instructions (i1, i2, i3, i4) moving through a ***classic 5-stage pipeline***

```list
classic 5 stage pipeline
* IF (Instruction fetch)
* ID (Instruction Decode)
* EX (Execute)
* MEM (Memory access)
* WB (Write Back)
```

| Clock cycle | I1(add R1, R2, R3) | I2(sub R4, R5, R6) | I3(load R7, O(R8)) | I4(store O(R4), R7) |
| --------------- | --------------- | --------------- | --------------- | --------------- |
| CC1 | IF |  |  |  |
| CC2 | ID | IF |  | |
| CC3 | EX | ID | IF | |
| CC4 | MEM | EX | ID | IF |
| CC5 | WB |MEM |EX |ID |
| CC6 |  | WB|MEM |EX |
| CC7 |  | | WB| MEM|
| CC8 |  | | | WB|


A Real world example is in concurrent manufacturing of automobiles


## Bus microarchitecture üòó

> microarchitecture -> (*aka* Computer organization) Detailed internal design of a computer processor. It shows how it is actually implemented in hardware.

### 2-Bus microarchitecture concept

* Uses 2 internal buses (BUS A and BUS B). This allows for the transfer of operands from registers to the ALU simultaneously

```diagram
                  ------------------------------
                  |        Control Unit         |
                  ------------------------------
                     |        |         |
                     |        |         |
                 ----        ----     ----
                |Sel A|     |Sel B|  |Sel C|
                 ----        ----     ----
                  |            |        |
   ----------------------------------------------------
   |                     Register File                 |
   |                                                   |
   |   R0     R1     R2     R3     ...     Rn          |
   |    |      |      |      |               |         |
   ----------------------------------------------------
      |                |                   |
      |                |                   |
   -----------     -----------      ------------------
   |  Bus A   |   |  Bus B   |      |  Dest Bus (C) |
   -----------     -----------      ------------------
        \             /                   |
         \           /                    |
          ----------------   ALU   --------------
                         \        /
                          --------
                             |
                             |
                      Write-back to Register

```

Working of a 2 bus architecture

Suppose we want to execute R3 <- R1 + R2

* Bus A collects content of R1
* Bus B collects content of R2
* ALU performs addition.
* Result is written to R3 via write-back bus.

In a 1 Bus architecture, it's limitations are

* We have only 1 shared internal bus
* Only 1 register value can move at a time
* To evaluate (say) R3 <- R1 + R2, multiple micro operations are needed.

```rand
Example, we wanna evaluate R3 <- R1 + R2

1-bus
t1 : Bus <- R1
t2 : Temp <- Bus
t3 : Bus <- R2
t4 : ALUout <- Temp + Bus
t5 : R3 <- ALUout
```

```rand
2-bus
t1 : A-Bus <- R1, B-Bus <- R2
t2 : R3 <- R1 + R2
```

So, advantages of 2 bus microarchitecture are

* parallelism
* reduced micro-operations
* higher throughput
* less control unit complexity
